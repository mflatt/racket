#lang racket/base
(require racket/include)

(provide known-procedures
         known-constructors
         known-struct-type-property/immediate-guards
         known-constants)

(define known-struct-type-property/immediate-guards
  '(prop:procedure
    prop:equal+hash
    prop:custom-write
    prop:evt
    prop:authentic))

;; Constructors with arities:
(define known-constructors
  '([cons 2]
    [list any]
    [vector any]))

(define-syntax-rule (make-primitive-table id ...)
  '(id ...))

(include "primitive/kernel.scm")
(include "primitive/unsafe.scm")
(include "primitive/flfxnum.scm")
(include "primitive/paramz.scm")
(include "primitive/extfl.scm")
(include "primitive/network.scm")
(include "primitive/futures.scm")
(include "primitive/place.scm")
(include "primitive/foreign.scm")
(include "primitive/linklet.scm")
(include "primitive/internal.scm")

(define all-primitives
  (append kernel-table
          unsafe-table
          flfxnum-table
          paramz-table
          extfl-table
          network-table
          futures-table
          place-table
          linklet-table
          internal-table))

(define-values (known-procedures known-constants)
  ;; Register primitives
  (let ([ns (make-base-namespace)])
    (parameterize ([current-namespace ns])
      (namespace-require 'racket/unsafe/ops)
      (namespace-require 'racket/flonum)
      (namespace-require 'racket/fixnum))
    (for/fold ([known-procedures null] [known-constants null]) ([s (in-list all-primitives)])
      (with-handlers ([exn:fail? (lambda (x) (values known-procedures known-constants))])
        (let ([v (eval s ns)])
          (cond
            [(and (procedure? v)
                  (not (parameter? v))
                  ;; could have a guard:
                  (not (struct-constructor-procedure? v)))
             (values (cons s known-procedures) known-constants)]
            [(or (memq s known-struct-type-property/immediate-guards)
                 (assq s known-constructors))
             (values known-procedures known-constants)]
            [else
             (values known-procedures (cons s known-constants))]))))))

(module+ main
  (require racket/pretty)
  
  (call-with-output-file
   "known-primitive.sls"
   #:exists 'truncate
   (lambda (o)
     (displayln ";; this file is generated by known-primitive.rkt" o)
     (pretty-write
      `(library (known-primitive)
        (export known-procedures
                known-constructors
                known-struct-type-property/immediate-guards
                known-constants)
        (import (chezscheme))
        (define known-procedures ',(sort known-procedures symbol<?))
        (define known-constructors ',known-constructors)
        (define known-struct-type-property/immediate-guards ',known-struct-type-property/immediate-guards)
        (define known-constants ',(sort known-constants symbol<?)))
      o))))
